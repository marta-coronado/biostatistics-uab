output$plot <- renderPlot({
filtered <-
CO2_df %>%
filter(uptake >= input$UptakeInput[1],
uptake <= input$UptakeInput[2],
Treatment %in% input$TreatmentInput
)
ggplot(filtered, aes(x = Treatment, y = uptake)) +
geom_boxplot() +
labs(title = "Variance of uptake according to Treatment",
x = "Treatment",
y = "Uptake")
})
output$results <- renderTable({
filtered <-
CO2_df %>%
filter(uptake >= input$UptakeInput[1],
uptake <= input$UptakeInput[2],
Treatment %in% input$TreatmentInput
)
filtered
})
}
shinyApp(ui = ui, server = server)
# Answer:
shinyApp(
ui = fluidPage(
fluidRow(
column(6,
plotOutput("tooth_plot", click = "click_action")
),
column(5,
htmlOutput(outputId = "x_value"),                                # <- html output
dataTableOutput("selected_rows")  # tableOutput("selected_rows")
)
)
),
server = function(input, output) {
library(ggplot2)
output$tooth_plot <- renderPlot({
ggplot(CO2_df, aes(conc,uptake, fill = Treatment)) +
geom_col()
})
var_levels <- levels(ToothGrowth$supp)
# Print the name of the x value
output$x_value <- renderText({
if (is.null(input$click_action$x)){
return("")
} else {
selected_level <- var_levels[round(input$click_action$x)]        # <- Levels are stored as integers! so 1 is OJ and 2 is VC
HTML("You've selected <code>", selected_level, "</code>",        # <- You can add html code to print nicer text :)
"<br><br>Here are the first 10 rows that ",
"match that category:")
}
})
# Print the rows of the data frame which match the x value
output$selected_rows <- renderDataTable({ # output$selected_rows <- renderTable({
if (is.null(input$click_action$x)) {
return()
} else {
selected_level <- var_levels[round(input$click_action$x)]
head(CO2_df[CO2_df$Treatment %in% selected_level, ], 10)
}
})
}
)
knitr::opts_chunk$set(echo = TRUE, fig.width = 9, fig.height = 6, fig.align = "center")
library(ggplot2)
library(shiny)
library(plotly)
library(dplyr)
library(shiny)
ui <- fluidPage(titlePanel("Plants Data"), strong("Lucía Navarro Torres"), p(em("7 April 2025")), sidebarLayout(checkboxGroupInput("plantInput", "Plant", choices = c("Qn1", "Qn2", "Qn3", "Qc1", "Qc2", "Qc3", "Mn1", "Mn2", "Mn3", "Mc1", "Mc2", "Mc3"), selected = "Qn1")))
mypalette=  c("#33A02C", "#FF7F00", "#1F78B4", "#6A3D9A")
plott <-ggplot(data = df, mapping = aes(time, value, fill=group)) +
geom_line() +
geom_point(data=df[df$value>45,], size=2)+
facet_grid(~group) +
scale_fill_manual(values = mypalette) +
theme(legend.position= "bottom")
scale_x_continuous(name = "Sepal width")
plott
ggplot(CO2_df, aes(x=Treatment, y=uptake , colour = Treatment))+
geom_jitter() +
geom_boxplot(fill=NA, show.legend = FALSE) +
#Show the mean of both groups
geom_hline(yintercept = mean(iris$Petal.Width), alpha=0.5)+
#Mark the maximum uptake point and the minimum one
geom_point(data=CO2_df[CO2_df$uptake ==max(CO2_df$uptake),], colour="red", shape=4, size=7 )+
geom_point(data=CO2_df[CO2_df$uptake ==min(CO2_df$uptake),], colour="blue", shape=4, size=7 ) +
geom_text(data=CO2_df[CO2_df$uptake ==max(CO2_df$uptake),],
aes(label = "Maximum uptake value")) +
geom_text(data=CO2_df[CO2_df$uptake ==min(CO2_df$uptake),],
aes(label = "Minimum uptake value"))
ui <- fluidPage(
titlePanel(HTML('<h1 style="color:darkred;">Glucose uptake</h1>
<hr><br>'
)),
sidebarLayout(
#interactive panel
sidebarPanel(
sliderInput("uptakevalues",
"Minumim uptake value",
min = 7.7, #min(CO2_df$uptake)
max = 45.5, #max(CO2_df$uptake)
value = 7.7),
radioButtons("treatmentInput", "Treatment",
choices = c("nonchilled", "chilled"),
selected = "nonchilled"),
mainPanel(
plotOutput("plot"),
br(),
)))
server <- function(input, output){
output$plot <- renderPlot({
boxplot1)
}
shinyApp(ui = ui, server = server)
library(ggplot2)
library(shiny)
library(shiny)
library(plotly)
expressionData <- df
ui = fluidPage(
titlePanel("CO2 Uptake in Echinochloa crus-galli"),
strong("Author:"), "Irene Porta", br(),
strong("Date:"), "07/03/2025", br(),
sidebarLayout(
sidebarPanel(
selectInput("TreatmentInput", "Treatment type", choices = c("non-chilled", "chilled"), selected = "non-chilled"),
checkboxGroupInput("TypeInput", "Type", choices = c("Quebec", "Mississippi"), selected = "Quebec"),
sliderInput("concInput", "Ambiental Concentration", min = 95, max = 1000,
value = c(675, 1000)),
sliderInput("uptakeInput", "Uptake", min = 7.7, max = 45.5,
value = c(35, 45.5))
),
mainPanel(textOutput("numResults"),plotOutput("plot"),br(), br(), tableOutput("results"))
)
)
server <- function(input, output) {
output$numResults <- renderText({
paste("Number of matching results:", nrow(filtered()))
})
output$plot <- renderPlot({
ggplot(CO2, aes(y = uptake, x = conc, fill = Treatment)) +
geom_col() +
labs(title = "Ambient concentration VS CO2 uptake in different Treatments", y = "CO2 Uptake", x = "Ambiental concentration", caption = "CO2 uptake increases with ambient CO2 concentration, but the effect differs by treatment.") +
facet_grid(.~Treatment) +
scale_fill_manual(values = c("darkorange", "darkgray")) +
theme_light()
})
output$results <- renderTable({
filtered <-
expressionData %>%
filter(
Treatment %in% input$TreatmentInput,
Type %in% input$TypeInput,
conc %in% input$concInput,
uptake %in% input$uptakeInput
)
filtered
})
}
shinyApp(ui = ui, server = server)
library(shiny)
shinyApp(
ui = fluidPage(
fluidRow(
column(6,
plotOutput("CO2_plot", click = "click_action")
),
column(5,
htmlOutput(outputId = "x_value"),                                # <- html output
tableOutput("selected_rows")
)
)
),
server = function(input, output) {
library(ggplot2)
output$CO2_plot <- renderPlot({
ggplot(CO2_df, aes(x = Treatment, y = uptake, fill = Type, colour = conc)) +
geom_boxplot()+
geom_jitter() +
facet_grid(cols = vars(Type), scales = "free_x", space = "free_x")+
theme_minimal() +
theme(legend.position = "bottom")
})
var_levels <- levels(CO2_df$Treatment)
# Print the name of the x value
output$x_value <- renderText({
if (is.null(input$click_action$x)){
return("")
} else {
selected_level <- var_levels[round(input$click_action$x)]        # <- Levels are stored as integers! so 1 is OJ and 2 is VC
HTML("You've selected <code>", selected_level, "</code>",        # <- You can add html code to print nicer text :)
"<br><br>Here are the first 10 rows that ",
"match that category:")
}
})
# Print the rows of the data frame which match the x value
output$selected_rows <- renderTable({
if (is.null(input$click_action$x)) {
return()
} else {
selected_level <- var_levels[round(input$click_action$x)]
head(CO2_df[CO2_df$Treatment %in% selected_level, ], 10)
}
})
}
)
data("CO2")
ui <- fluidPage(
titlePanel("CO2 Uptake Analysis - Erick Rodríguez"),
sidebarLayout(
sidebarPanel(
radioButtons("treatment", "Select Treatment:",
choices = c("Show All", "chilled", "nonchilled"),
selected = "Show All"),
sliderInput("conc_range", "CO2 Concentration:",
min = min(CO2$conc),
max = max(CO2$conc),
value = range(CO2$conc),
step = 5)
),
mainPanel(
plotOutput("co2_plot"),
DTOutput("data_table")
)
)
)
server <- function(input, output) {
filtered_data <- reactive({
data <- CO2
if (input$treatment != "SHOW ALL") {
data <- data[data$Treatment == input$treatment, ]
}
data <- data[data$conc >= input$conc_range[1] &
data$conc <= input$conc_range[2], ]
validate(
need(nrow(data) > 0, "No data matches with filters")
)
data
})
output$co2_plot <- renderPlot({
ggplot(filtered_data(), aes(x = conc, y = uptake, color = Treatment)) +
geom_point(size = 3) +
geom_smooth(method = "lm", se = FALSE) +
labs(title = "CO2 UPTAKE/CONC", x = "CO2 CONC", y= "CO2 UPTAKE") +
theme_minimal()
})
output$data_table <- renderDT({
datatable(filtered_data())
})
}
shinyApp(ui, server)
library(shiny);library(DT)
shinyApp(
ui = fluidPage(
fluidRow(
column(6,
plotOutput("CO2_plot", click = "click_action")
),
column(5,
htmlOutput(outputId = "x_value"),                                # <- html output
tableOutput("selected_rows")
)
)
),
server = function(input, output) {
library(ggplot2)
output$CO2_plot <- renderPlot({
ggplot(CO2_df, aes(x = Treatment, y = uptake, fill = Type, colour = conc)) +
geom_boxplot()+
geom_jitter() +
facet_grid(cols = vars(Type), scales = "free_x", space = "free_x")+
theme_minimal() +
theme(legend.position = "bottom")
})
var_levels <- levels(CO2_df$Treatment)
# Print the name of the x value
output$x_value <- renderText({
if (is.null(input$click_action$x)){
return("")
} else {
selected_level <- var_levels[round(input$click_action$x)]        # <- Levels are stored as integers! so 1 is OJ and 2 is VC
HTML("You've selected <code>", selected_level, "</code>",        # <- You can add html code to print nicer text :)
"<br><br>Here are the first 10 rows that ",
"match that category:")
}
})
# Print the rows of the data frame which match the x value
output$selected_rows <- renderTable({
if (is.null(input$click_action$x)) {
return()
} else {
selected_level <- var_levels[round(input$click_action$x)]
head(CO2_df[CO2_df$Treatment %in% selected_level, ], 10)
}
})
}
)
library(DT)
ui <- fluidPage(
titlePanel("CO2 Uptake Analysis - Erick Rodríguez"),
sidebarLayout(
sidebarPanel(
radioButtons("treatment", "Select Treatment:",
choices = c("Show All", "chilled", "nonchilled"),
selected = "Show All"),
sliderInput("conc_range", "CO2 Concentration:",
min = min(CO2$conc),
max = max(CO2$conc),
value = range(CO2$conc),
step = 5)
),
mainPanel(
plotOutput("co2_plot"),
DTOutput("data_table")
)
)
)
server <- function(input, output) {
filtered_data <- reactive({
data <- CO2
if (input$treatment != "SHOW ALL") {
data <- data[data$Treatment == input$treatment, ]
}
data <- data[data$conc >= input$conc_range[1] &
data$conc <= input$conc_range[2], ]
validate(
need(nrow(data) > 0, "No data matches with filters")
)
data
})
output$co2_plot <- renderPlot({
ggplot(filtered_data(), aes(x = conc, y = uptake, color = Treatment)) +
geom_point(size = 3) +
geom_smooth(method = "lm", se = FALSE) +
labs(title = "CO2 UPTAKE/CONC", x = "CO2 CONC", y= "CO2 UPTAKE") +
theme_minimal()
})
output$data_table <- renderDT({
datatable(filtered_data())
})
}
shinyApp(ui, server)
ui <- fluidPage(
titlePanel('Shiny Application exam'), br(),strong('Made by Nil Saura'),
sidebarLayout(
sidebarPanel(
sliderInput("C02_uptake", "Choose a range:",
min = 0, max = 1000, value = c(0, 10), step = 10),
radioButtons("Treatment1", "Treatment Group",
choices = c("NonChilled", "Chilled"),
selected = "NonChilled")),
mainPanel(plotOutput('pl'),br(),
br(),
tableOutput("results"))
)
)
server <- function(input, output) {
output$pl <- renderPlot({
filtered <- CO2_df %>%
filter(uptake >= input$CO2_uptake[1],
uptake <= input$CO2_uptake[2],
Treatment %in% input$Treatment1)
ggplot(filtered, aes(y= uptake, x = Treatment))+ geom_boxplot()+ theme_minimal() + labs(y = 'Uptake concentration', title = 'Higher CO2 uptake under non-chilled conditions')
})
output$results <- renderTable({
filtered <- CO2_df %>%
filter(uptake >= input$CO2_uptake[1],
uptake <= input$CO2_uptake[2],
Treatment %in% input$Treatment)
filtered
})
}
shinyApp(ui = ui, server = server)
library(ggplot2)
library(dplyr)
library(shiny)
# Define UI for application that draws a histogram
ui <- fluidPage(
# Application title
titlePanel("CO2 uptake chilled vs no chilled"),
# Sidebar
sidebarLayout(
sidebarPanel(
sliderInput("uptakeinput",
"Uptake",
min = -6, max = 12,
value = c(1, 5)
),
radioButtons("treat_inp", "treatment",
choices = c("chilled", "non chilled"),
selected = "chilled"),
# Show a plot of the generated distribution
mainPanel(
plotOutput("Plot")
)
)
))
# Define server logic required to draw a histogram
server <- function(input, output) {
# Filter the data based on user inputs
filteredData <- reactive({
CO2_df %>%
filter(
uptake >= input$uptakeinput[1],
uptake <= input$uptakeinput[2],
Treatment %in% input~treat_inp
)
})
output$Plot <- renderPlot({
ggplot(CO2_df, aes(uptake, conc))+
geom_jitter()+
facet_grid(~Treatment)+
geom_smooth()
})
}
# Run the application
shinyApp(ui = ui, server = server)
ggplot(CO2_df, aes(x = conc, y = uptake, fill = Treatment))+
geom_col() +
facet_grid(cols = vars(Treatment))
ui <- fluidPage(
# Add a title related to expression data
titlePanel("CO2 Uptake variation"),
tags$strong("Author: Jos Trias Betorz"),
tags$hr(),
sidebarLayout(
sidebarPanel(selectInput("Treatment_input", "Select Treatment",
choices = c("chilled", "non-chilled"),
selected = "non-chilled"),
sliderInput("uptake_range",
"range of CO2 uptake",
min = 0, max = 1000,
value = c(1, 5)
)
),
mainPanel(
plotOutput("Plot_2"))
)
)
server <- function(input, output) {
output$Plot_2 <- renderPlot({
ggplot(CO2_df, aes(x = conc, y = uptake, fill = Treatment))+
geom_col() +
facet_grid(cols = vars(Treatment))
})
}
shinyApp(ui, server)
setwd("C:/Users/Marta/Dropbox/DOCENCIA/UAB/Genètica/Bioestadística/Seminarios/S1")
setwd("C:/Users/Marta/OneDrive - UAB/Bioestadística/Seminarios/S1")
unlink("S1_cache", recursive = TRUE)
unlink("S1_cache", recursive = TRUE)
world <- data.table::fread("img/Mundo_ Producto interior bruto (2024).csv")
setwd("C:/Users/Marta/OneDrive - UAB/Bioestadística/Prácticas/P1")
unlink("C:/Users/Marta/OneDrive - UAB/Bioestadística/Teoría/1.Estadística descriptiva/1.EstadisticaDescriptiva_cache", recursive = TRUE)
set.seed(42) # para hacer el código reproducible
data_vec <- rexp(100, rate = 0.1) + 10
set.seed(42) # para hacer el código reproducible
data_vec <- rexp(100, rate = 0.1) + 10
df <- data.frame(valor=data_vec)
q_vals <- quantile(df$valor, probs = c(0.25, 0.5, 0.75))
ggplot(df, aes(x = 1, y = valor)) +
geom_boxplot(width = 0.1, fill = "orange", alpha = 0.7, outlier.color = "orange3") +  # boxplot
stat_summary(fun = mean, geom = "point", shape = 23, size = 3, fill = "firebrick3") +  # media
# Anotaciones de Q1, Mediana y Q3
annotate("text", x = 1.08, y = q_vals[1],
label = paste0("← Q1 ", round(q_vals[1], 2)),
hjust = 0, size = 5, color = "purple4") +
annotate("text", x = 1.08, y = q_vals[2],
label = paste0("← Mediana ", round(q_vals[2], 2)),
hjust = 0, size = 5, color = "blue4") +
annotate("text", x = 1.08, y = q_vals[3],
label = paste0("← Q3 ", round(q_vals[3], 2)),
hjust = 0, size = 5, color = "darkgreen") +
labs(title = "Boxplot con outliers",
x = "", y = "") +
theme_minimal(base_size = 18) +
theme(panel.grid = element_blank(),
axis.text.x = element_blank(),
axis.ticks.x = element_blank(),
axis.text = element_text(color = "black")) +
xlim(c(0.7,1.5))
ibrary(ggplot2)
library(ggplot2)
set.seed(42) # para hacer el código reproducible
data_vec <- rexp(100, rate = 0.1) + 10
df <- data.frame(valor=data_vec)
q_vals <- quantile(df$valor, probs = c(0.25, 0.5, 0.75))
ggplot(df, aes(x = 1, y = valor)) +
geom_boxplot(width = 0.1, fill = "orange", alpha = 0.7, outlier.color = "orange3") +  # boxplot
stat_summary(fun = mean, geom = "point", shape = 23, size = 3, fill = "firebrick3") +  # media
# Anotaciones de Q1, Mediana y Q3
annotate("text", x = 1.08, y = q_vals[1],
label = paste0("← Q1 ", round(q_vals[1], 2)),
hjust = 0, size = 5, color = "purple4") +
annotate("text", x = 1.08, y = q_vals[2],
label = paste0("← Mediana ", round(q_vals[2], 2)),
hjust = 0, size = 5, color = "blue4") +
annotate("text", x = 1.08, y = q_vals[3],
label = paste0("← Q3 ", round(q_vals[3], 2)),
hjust = 0, size = 5, color = "darkgreen") +
labs(title = "Boxplot con outliers",
x = "", y = "") +
theme_minimal(base_size = 18) +
theme(panel.grid = element_blank(),
axis.text.x = element_blank(),
axis.ticks.x = element_blank(),
axis.text = element_text(color = "black")) +
xlim(c(0.7,1.5))
